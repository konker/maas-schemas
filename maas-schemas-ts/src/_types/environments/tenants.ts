/*

undefined
undefined

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';
import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import { nonEmptyArray } from 'io-ts-types/lib/nonEmptyArray';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export interface DefinedC extends DefinedType {}
export const Defined: DefinedC = new DefinedType();

export const schemaId = 'https://schemas.maas.global/environments/tenants.json';

// TenantId
// The purpose of this remains a mystery
export type TenantId = t.Branded<string, TenantIdBrand>;
export type TenantIdC = t.BrandC<t.StringC, TenantIdBrand>;
export const TenantId: TenantIdC = t.brand(
  t.string,
  (x): x is t.Branded<string, TenantIdBrand> =>
    typeof x !== 'string' || x.match(RegExp('^[a-z]{2,20}$')) !== null,
  'TenantId',
);
export interface TenantIdBrand {
  readonly TenantId: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(TenantId)).decodeSync(examplesTenantId) // => examplesTenantId */
export const examplesTenantId: NonEmptyArray<TenantId> = ([
  'multipol',
  'whim',
] as unknown) as NonEmptyArray<TenantId>;

// TenantName
// The purpose of this remains a mystery
export type TenantName = t.Branded<string, TenantNameBrand>;
export type TenantNameC = t.BrandC<t.StringC, TenantNameBrand>;
export const TenantName: TenantNameC = t.brand(
  t.string,
  (x): x is t.Branded<string, TenantNameBrand> => true,
  'TenantName',
);
export interface TenantNameBrand {
  readonly TenantName: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(TenantName)).decodeSync(examplesTenantName) // => examplesTenantName */
export const examplesTenantName: NonEmptyArray<TenantName> = ([
  'Multipol',
  'Whim',
] as unknown) as NonEmptyArray<TenantName>;

// TenantDescription
// The purpose of this remains a mystery
export type TenantDescription = t.Branded<string, TenantDescriptionBrand>;
export type TenantDescriptionC = t.BrandC<t.StringC, TenantDescriptionBrand>;
export const TenantDescription: TenantDescriptionC = t.brand(
  t.string,
  (x): x is t.Branded<string, TenantDescriptionBrand> => true,
  'TenantDescription',
);
export interface TenantDescriptionBrand {
  readonly TenantDescription: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(TenantDescription)).decodeSync(examplesTenantDescription) // => examplesTenantDescription */
export const examplesTenantDescription: NonEmptyArray<TenantDescription> = ([
  'Multipol tenant',
  'Whim tenant',
] as unknown) as NonEmptyArray<TenantDescription>;

// Tenant
// The purpose of this remains a mystery
export type Tenant = t.Branded<
  ({
    name?: TenantName;
    description?: TenantDescription;
  } & Record<string, unknown>) & {
    name: Defined;
  },
  TenantBrand
>;
export type TenantC = t.BrandC<
  t.IntersectionC<
    [
      t.IntersectionC<
        [
          t.PartialC<{
            name: typeof TenantName;
            description: typeof TenantDescription;
          }>,
          t.RecordC<t.StringC, t.UnknownC>,
        ]
      >,
      t.TypeC<{
        name: typeof Defined;
      }>,
    ]
  >,
  TenantBrand
>;
export const Tenant: TenantC = t.brand(
  t.intersection([
    t.intersection([
      t.partial({
        name: TenantName,
        description: TenantDescription,
      }),
      t.record(t.string, t.unknown),
    ]),
    t.type({
      name: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    ({
      name?: TenantName;
      description?: TenantDescription;
    } & Record<string, unknown>) & {
      name: Defined;
    },
    TenantBrand
  > => true,
  'Tenant',
);
export interface TenantBrand {
  readonly Tenant: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(Tenant)).decodeSync(examplesTenant) // => examplesTenant */
export const examplesTenant: NonEmptyArray<Tenant> = ([
  { name: 'Multipol Api', description: 'This tenant is used for fun stuff' },
  { name: 'Whim Api', description: 'This tenant is used for other stuff' },
] as unknown) as NonEmptyArray<Tenant>;

// TenantIndex
// The purpose of this remains a mystery
export type TenantIndex = t.Branded<
  Record<TenantId, unknown> & Record<string, Tenant>,
  TenantIndexBrand
>;
export type TenantIndexC = t.BrandC<
  t.IntersectionC<
    [t.RecordC<typeof TenantId, t.UnknownC>, t.RecordC<t.StringC, typeof Tenant>]
  >,
  TenantIndexBrand
>;
export const TenantIndex: TenantIndexC = t.brand(
  t.intersection([t.record(TenantId, t.unknown), t.record(t.string, Tenant)]),
  (
    x,
  ): x is t.Branded<
    Record<TenantId, unknown> & Record<string, Tenant>,
    TenantIndexBrand
  > => true,
  'TenantIndex',
);
export interface TenantIndexBrand {
  readonly TenantIndex: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(TenantIndex)).decodeSync(examplesTenantIndex) // => examplesTenantIndex */
export const examplesTenantIndex: NonEmptyArray<TenantIndex> = ([
  {
    multipol: { name: 'Multipol Api' },
    whim: { name: 'Whim Api', description: 'This tenant is used for other stuff' },
  },
] as unknown) as NonEmptyArray<TenantIndex>;

// Tenants
// The default export. More information at the top.
export type Tenants = t.Branded<unknown, TenantsBrand>;
export type TenantsC = t.BrandC<t.UnknownC, TenantsBrand>;
export const Tenants: TenantsC = t.brand(
  t.unknown,
  (x): x is t.Branded<unknown, TenantsBrand> => true,
  'Tenants',
);
export interface TenantsBrand {
  readonly Tenants: unique symbol;
}

export default Tenants;

// Success
